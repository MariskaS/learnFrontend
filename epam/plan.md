## Helpful links:
### Js
- [Основы ООП](https://habr.com/ru/post/345658/)
- [Vladilen M - JS course](https://www.vladilen.dev/javascript)
- [JS tasks - interviewcake](https://www.interviewcake.com/question/javascript/js-scope)
- [JS: Interview Questions](https://khan4019.github.io/front-end-Interview-Questions/sort.html)
- [learn.javascript.ru/async-await](https://learn.javascript.ru/async-await)
- [learn.javascript.ru/bubbling-and-capturing](https://learn.javascript.ru/bubbling-and-capturing)
- [learn.javascript.ru/promise-basics](https://learn.javascript.ru/promise-basics)
- [learn.javascript.ru/promise-chaining](https://learn.javascript.ru/promise-chaining)
- [medium - Observable в RxJS: краткое введение](https://medium.com/@kosmogradsky/observable-%D0%B2-rxjs-%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-34939ff5f7d7)
- [medium - RxJS с нуля, обзор “Обозреваемого”](https://medium.com/@toshabely/rxjs-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BE%D0%B1%D0%B7%D0%BE%D1%80-%D0%BE%D0%B1%D0%BE%D0%B7%D1%80%D0%B5%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F-ca4d8e5fb386)
- [medium - introducing-to-reactive-programming](https://medium.com/ngx/introducing-to-reactive-programming-984c1a390e2d)
- [positive-js.github.io - rxjs](https://positive-js.github.io/blog/rxjs/reactive)
- [medium - introducing-to-reactive-programming-with-rxjs](https://medium.com/ngx/introducing-to-reactive-programming-with-rxjs-3583345faec19)
- [medium - introducing-to-reactive-programming](https://medium.com/ngx/introducing-to-reactive-programming-984c1a390e2d)
- [prototype](https://webdevblog.ru/chem-prototipnoe-nasledovanie-otlichaetsya-ot-klassicheskogo/)
- [youtube - JavaScript. Что такое prototype. JavaScript Prototype V.Minin](https://www.youtube.com/watch?v=aQkgUUmUJy4)
- [medium - Вы не знаете JS: типы данных и значения](https://medium.com/@Dimetrio89/%D0%B2%D1%8B-%D0%BD%D0%B5-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-js-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-f95a605de82)
- [medium - eventloop](https://medium.com/devschacht/javascript-eventloop-explained-f2dcf84e36ee)
- [Функция обратного вызова](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0)
- [Классы, объекты и наследование в JavaScript](https://habr.com/ru/post/15444/)

### Algorithms
- [algorithms - coursera](https://www.coursera.org/learn/algorithms-part1#syllabus)
- [JS: Interview Algorithm](http://www.thatjsdude.com/interview/js1.html)
- [Графики основных математических функций, факториал, понятие логарифма.]
- [Задачи на применение алгоритмов](https://www.codewars.com/kata/search/java?q=&r%5B%5D=-7&tags=Algorithms&beta=false)

### Angular / RXJs
- [Rolling Scopes - Angular course - список тем](https://docs.rs.school/#/angular-course)
- [Евгений Поздняков — RxJS: производительность и утечки памяти в большом приложении](https://www.youtube.com/watch?v=7806msvJ1HE&t=513s)
- [assign](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
- [material.angular.io/cdk/](https://material.angular.io/cdk/categories)
- [Декораторы @ContentChild, @ContentChildren, @ViewChildren, @ViewChild и TemplateOutlet с ng-container в Angular](http://coldfox.ru/article/5bd60bbb9227d914a1c83fe2/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-ContentChild-ContentChildren-ViewChildren-ViewChild-%D0%B8-TemplateOutlet-%D1%81-ng-container-%D0%B2-Angular)
- [angular-change-detection](https://webdraftt.com/tutorial/angular-change-detection)
- [medium - Subject в RxJS: краткое введение](https://medium.com/@kosmogradsky/subject-%D0%B2-rxjs-%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-c9099231be6d)
- [Change-detection](http://www.coldfox.ru/article/5c34d3d1e1969f269b611179/Change-detection-%D0%B2-Angular)
- [Полное руководство по стратегии обнаружения изменений Angular onPush](https://habr.com/ru/company/infopulse/blog/358860/)
- [RxJS: Введение в Subject в реактивном программировании](https://dev-gang.ru/article/rxjs-vvedenie-v-subject-v-reaktivnom-programmirovanii-qp4tshapir/)
- [subject rxjs](https://rxjs.dev/guide/subject)
- [RxJS: все о Subjects, Behavior Subjects и Replay Subjects](https://golosay.net/rxjs-subjects/)

### Tests
- [Rolling Scopes - тесты](https://www.youtube.com/watch?v=xrS60rkoG3w&feature=youtu.be)
- [Rolling Scopes - тесты 2](https://www.youtube.com/watch?v=qFSrImO04X8&feature=youtu.be)

### HTML/CSS
- [Веса селекторов - CSS]
- [em vs rem, относительные и абсолютные величины - CSS]

### Others
- [interview - mariskas](https://github.com/MariskaS/learnFrontend/blob/master/lectures/interview.md)
- [Vladilen M - youtube](https://www.youtube.com/channel/UCg8ss4xW9jASrqWGP30jXiw)
- [learning - Mastering Web Developer Interview Code](https://www.linkedin.com/learning/mastering-web-developer-interview-code/welcome)
- [Rolling Scopes School - youtube](https://www.youtube.com/channel/UC578nebW2Mn-mNgjEArGZug/videos)
- [Rolling Scopes - youtube](https://www.youtube.com/user/therollingscopes)
- [Rolling Scopes - календарь с полезными заметками](https://docs.google.com/spreadsheets/d/1oM2O8DtjC0HodB3j7hcIResaWBw8P18tXkOl1ymelvE/edit#gid=1509181302)
- [Rolling Scopes - interview questions - github](https://github.com/rolling-scopes-school/tasks/blob/master/tasks/interview-corejs.md)

# Notices

Life hooks
@viewChild
@contentChild
@HostBinding
Promise; async/await; Observable; Take/TakeUntil; Sabject(BehaiverSubj...); async pipe
Guards; CDK; 
Closures
Prototype
-----------
## @viewChild 
1. дает доступ к референсу указанному в html компонента
export class CategoriesFormComponent implements OnInit {
  @ViewChild('input', {static: false}) inputRef: ElementRef; 
  или для получения объекта @ViewChildren(AlertComponent, { read: ElementRef }) alerts: QueryList<ElementRef>
  // в последней версии не нужно указывать  {static: false}, теперь это по дефолту
2. The QueryList is initialized only before the ngAfterViewInit lifecycle hook, therefore, is available only from this point.
https://netbasal.com/understanding-viewchildren-contentchildren-and-querylist-in-angular-896b0c689f6e  

3. @ViewChild отличается от @ViewChildren тем, что первая всегда вернет вам только один элемент,
в то время как вторая позволяет вам находить несколько элементов, возвращая вам объект типа QueryList.

## @contentChild
дает доступ к содержимому ng-content данного компонента. Например:
1. например в компоненте tabs.ts пишем @ContentChildren(TabComponent) tabs: QueryList<TabComponent>
в его template пишем <ng-content></ng-content>
2. в другом компоненте в шаблоне вставляем 
<tabs>
 <tab title="One"></tab>
 <tab title="Two"></tab>
</tabs>
3. теперь компонент tabs имеет доступ ко всем табам  <tab>
4. The QueryList is initialized only before the ngAfterContentInit lifecycle hook, therefore, is available only from this point.
## ViewChildren vs ContentChildren
- ViewChildren don’t include elements that exist within the ng-content tag.
- ContentChildren includes only elements that exists within the ng-content tag.

## QueryList API  
Getters: 
- first — get the first item
- last — get the last item
- length — get the items length
Methods: map(), filter() , find(), reduce(), forEach(), some().
- toArray() — returns the items as javascript array
- changes() — Changes can be observed by subscribing to the changes Observable. Any time a child element is added,
removed, or moved, the query list will be updated, and the changes observable of the query list will emit a new value.

--------------

## EventLoop
все асинхр.функции помещаются в callback queue (очередь обратного вызова)

## что про перфоманс
- отписки от потоков 
- changeDetection: ChangeDetectionStrategy.OnPush
- Angular 9 - Ahead-of-Time (AOT) - compiles your app and libraries at build time(превращает код в набор инструкций во время сборки)
- Angular 8 - Just-in-Time (JIT) - compiles your app in the browser at runtime
- ivi 
	1.
- шедоу(перерендорит только нужный компонент) дом отличие от виртуал(ререндеринг компонента вместе с дитьми) дом

## 1. scope бывает локальный(function(var) /block(let/const)) и глобальный(браузер = window/node = global)
- scope наследуется - функция ребенок имеет доступ к переменным родителя.
- hoisting - подъем переменных(именно их декларирование, не значение) в своем scope 

## 2. Контекст - это сам объект в котором вызвана функция
- в случае apply, call или bind - this это объект, который передается в качестве аргумента.

## 3.прототипное наследование - Все объекты имеют свойство prototype, которое является ссылкой на другой объект
(например глобальный класс Object или String).
 Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript 
 просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, 
 пока не найдет определенное свойство на одном из прототипов или до тех пор, 
 пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, 
 но на самом деле это скорее делегирование, чем наследование.
 
## 4. Замыкание -  это функции, которые имеют доступ к переменным внешней (замыкающей) функции.
используется для эмуляции скрытых методов и может быть применен карринг.

```
function sum(a){
	return function f1(b) {
		return function f2(c){
			return a+b+c
		}
	}
}
или: const sum = a => b => c => a+b+c
console.log(sum(1)(2)(3))
```
## 5. разница между `.call` и `.apply` - add.call(newThis, 1, 2) | add.apply(newThis, arr)

## runtime - определенный процесс в оперативной памяти 
который очень просто работает, то есть если он запущен то он 
откликается на команды если же он не запущен 
то соответственно нет.

Среда выполнения — вычислительное окружение, 
необходимое для выполнения программы и доступное 
во время выполнения программы.

## Dependency Injection(DI) - паттерн проектирования.
Самый главный - root injector. Он регистрирует все сервисы
```
@Injectable({
  providedIn: 'root'
})
```

## ChangeDetectionStrategy.OnPush
По умолчанию ChangeDetectionStrategy.Default - если в радителе сработал механизм ChangeDetection - потомки компонента 
тоже отреагируют.
OnPush ChangeDetection: его включение в компонент говорит о том что ChangeDetection техника будет 
срабатывать только на инпуты.

@Component({
	selector: '...',
	...
	ChangeDetection: ChangeDetectionStrategy.OnPush
})

## референсы на элемент `#name` - получение в компоненте и родителе.
@VueChild (static - динамичный или нет)
пример с таблицей - чтобы при изменении в модели не делать ререндеринг всей таблицы мы можем просто рисовать одну новую строку.

## Zone -  дает возможность запустить таски вне ангуляровской зоны(с помощью функции runOutsideAngular)
Если функционал тригерит ченждекшен чаще чем это нужно(пример с сеттаймау 
на прогрессбаре) - можно обернуть функцию в this.ngZone.RuOutsideAngular(() => {...})
- все что обернуто в эту функцию не обрабатывается хуками ангулар - что значит что не будет вызываться автоматический ченждетесшн.
RuOutsideAngular - имеет свои методы которые вызывают хуки.

-

## 1. duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
function duplicate(arr) { return arr.concat(arr);}
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]

## 2. цикл, который перебирает числа до 100, возвращая ”fizz” на числа кратные 3, ”buzz” 
на числа кратные 5 и ”fizzbuzz” на числа кратные 3 и 5 ()
for (let i = 1; i <= 100; i++) {
  let f = i % 3 == 0, b = i % 5 == 0;
  if(f){
	console.log('Fizz')
  } else if(b){
	console.log('Buzz')
  } else if (f && b) {
	console.log('FizzBuzz')
  } else {
	console.log(i)
  }
}

## Фибоначи: Fn = Fn-1 + Fn-2. То есть, следующее число получается как сумма двух предыдущих.
первые два числа равны либо 1 и 1, либо 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел.
// => 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...
const fib = n => {
    let prev = 0;
    let next = 1;

    for (let i = 0; i < n; i++) {
        next = prev + next;
        prev = next - prev;
    }

    return prev;
}

console.log(fib(9))

### Мемомоизация - сохранение результатов выполнения функций для предотвращения повторных вычислений. 
Мы просто запоминаем результаты предыдущих вызовов вместо того, чтобы вычислять их заново.
Предотвращение повторных вычислений - это один из способов оптимизации.

let memo = [];
// для оптимизации запоминаем в глобальный массив -
// результаты предыдущих вызовов вместо того, чтобы вычислять их заново.

const fib = n => {
    if (memo[n]) return memo[n];
    // TODO: WTF console.log('fesrf', memo[n])

    let current = 0;
    let next = 1;

    for (let i = 0; i < n; i++) {
        memo[i] = current;
        // console.log(`memo[i] ${i}: `, current);
        // step 0: memo[i] => 0;
        // step 1: memo[i] => 1;
        // step 2: memo[i] => 1;
        // step 3: memo[i] => 2;
        // step 4: memo[i] => 3;
        // step 2: memo[i] => 5;

        // console.log(`memo step ${i}: `, memo);
        // step 0: memo => [0];
        // step 1: memo => [0, 1];
        // step 2: memo => [0, 1, 1];
        // step 3: memo => [0, 1, 1, 2];
        // step 4: memo => [0, 1, 1, 2, 3];
        // step 5: memo => [0, 1, 1, 2, 3, 5];

        [current, next] = [next, current + next] // swap
        // console.log(`swap step ${i}: `, [current, next]);
        // step 0: swap => [ 1, 1 ];
        // step 1: swap => [ 1, 2 ];
        // step 2: swap => [ 2, 3 ];
        // step 3: swap => [ 3, 5 ];
        // step 4: swap => [ 5, 8 ];
        // step 5: swap => [ 8, 13 ];
    }

    return current;
}

console.log(fib(8)); // 34
// console.log(fib(8)); // 21
console.log('global memo', memo); // [0, 1,  1,  2, 3, 5, 8, 13, 21]


## 3.  const Person = function() {return 'a';}
var p1 = Person; // p1 = function() {return 'a';}
var p2 = Person(); // p2 = а
var p3 = new Person(); // p3 = instance класса Person | Person.prototype.b1 = 4 -> p3

## Задачи
https://medium.com/webbdev/js-2b0820b3788f
https://www.youtube.com/watch?v=YlxIvmrijmY - анаграмма.

## Найти время за которое падает лепесток.
найти расстояние: S(расстояние)=t(время)*v(скорость), S=50*20(пример)
найти время: t(время)=S(расстояние):V(скорость)
найти скорость: V(скорость)=S(расстояние):T(время).

Cкорость падения лепестка составляет 5 сантиметров в секунду (5 см/с), 
и лепестку требуется 80 секунд, чтобы достичь земли с определенной ветви.
Напишите функцию, которая получает скорость (в см/с) лепестка в качестве входного сигнала и возвращает время,
которое требуется для того, чтобы этот лепесток достиг земли из той же ветви. 
*Если начальная скорость не положительна, возвращаемое значение должно быть 0

const sakuraFall = (v) => {
  // [condition] 5cm/1s => 80seconds - to reach the ground 
  // [какое растояние ?]: t*v => 5*80 => S = 400
  // [return] время: t(время)=S(расстояние):V(скорость)
  // T = 400(s) : 10(v)
  
  if (v <= 0) return 0;

  return 400/v
  
}
