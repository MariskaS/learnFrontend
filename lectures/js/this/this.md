# Как работает ключевое слово this?
1. [Определение](#Определение)
1. [4_варианта_вызова](#4_варианта_вызова)
1. [Apply_Call](#Apply_Call)
1. [Метод_объекта](#Метод_объекта)
1. [Режим_конструктора](#Режим_конструктора)
1. [У_стрелочных_функций_нет_this](#У_стрелочных_функций_нет_this)
1. [Полезные_ссылки_и_спасибо_за_предоставленные_материалы](#Полезные_ссылки_и_спасибо_за_предоставленные_материалы)

# Определение
Значение `this` в javascript не привязывается статически ни к какому объекту, а **зависит от контекста вызова**.  

Другими словами - В JavaScript `this` это **текущий контекст исполнения функции**. Поскольку функцию можно вызвать четырьмя способами:
- вызов функции: `alert('Hello World!')`,
- вызов метода: `console.log('Hello World!')`,
- вызов конструктора: `new RegExp('\\d')`,
- непрямой вызов: `alert.call(undefined, 'Hello World!')`,  

И каждый из них определяет свой контекст.

# 4_варианта_вызова
## 1. как функция
```js
func(параметры) // this = window
```
При таком вызове `this` ставится равным глобальному объекту (в браузере это `window`).

## 2. как метод
```js
obj.func(параметры) // this = obj
obj["func"](параметры) // this = obj
```
## 3. apply/call
```js
func.applay(obj, [параметры]) // this = obj
func.call(obj, параметры) // this = obj
```
## 4. конструктор
```js
new func(параметры) // this = новый объект
```

# Apply_Call
Функцию можно вызвать, используя методы `call` и `apply`.
```js
func.apply(obj, [параметры])
func.call(obj, параметр)
```
При таком вызове `this` будет установлен в `obj`.

Оба метода работают одинаково, но для `call` аргументы подставляются в вызов, а для `apply` - передается массив.

```js
function sum(a,b) {
    this.c = a + b
}

var obj = {}

sum.call(obj, 1,2)

// или
sum.apply(obj, [1,2])

alert(obj.c)   // => 3
```

# Метод_объекта
Если функция запущена как свойство объекта, то в `this` будет ссылка на этот объект.
```js
obj.func(параметры)
// или
obj['func'](параметры)
```
При этом совершенно неважно, откуда эта функция взялась. Важно лишь, какой перед func стоит объект.
## Пример:
```js
let user = { name: "Джон" };
let admin = { name: "Админ" };

function sayHi() {
  alert( this.name );
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// вызовы функции, приведённые ниже, имеют разное значение this
// "this" внутри функции является ссылкой на объект, который указан "перед точкой"
user.f(); // Джон  (this == user)
admin.f(); // Админ  (this == admin)

admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)
```
# Режим_конструктора
Если функция вызывается через `new` как конструктор объекта, то `this` ставится на создаваемый объект:
```js
function Animal(name) {
    this.name = name
}
animal = new Animal("test") // name: "test"
```
В результате получается объект, инициализированный конструктором, с заполненным свойством name.

# У_стрелочных_функций_нет_this
Стрелочные функции не имеют своего собственного `this`.   
Если мы используем `this` внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции. 
```js
let user = {
  firstName: "Илья",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Илья
```
Стрелочные функции полезны, когда мы на самом деле не хотим иметь отдельное значение `this`, а хотим брать его из внешнего контекста. 


# Полезные_ссылки_и_спасибо_за_предоставленные_материалы:
- [Методы объекта, "this" - learn.javascript](https://learn.javascript.ru/object-methods)
- [Ключевое слово "this" в деталях - javascript.ru](https://javascript.ru/tutorial/object/thiskeyword)
- [Что такое контекст this. Как работает call, bind, apply (youtube - Владилен Минин)](https://www.youtube.com/watch?v=UGapN-hrekw)